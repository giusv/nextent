(in-package :doc)

(defprim empty ()
  (:pretty () (list 'empty))
  (:output (*) (format t ""))
  (:string () "")
  (:doc () this)
  (:extent () 0))

(defprim text (template &rest args)
  (:pretty () `(text (:template ,template :args ,args)))
  (:output (indent) (format t "~v,0t~?" indent template args))
  (:string () (with-output-to-string (*standard-output*)
                (synth :output this 0)))
  ;; (:doc () (apply #'text template args))
  (:doc () this)
  (:extent () (length (apply #'format nil template args))))

(defprim nest (amount doc)
  (:pretty () `(nest (:amount ,amount :doc ,(synth :pretty doc))))
  (:output (indent) (synth :output doc (+ indent amount)))
  (:string () (with-output-to-string (*standard-output*)
			(synth :output this 0)))
  (:doc () this)
  (:extent () (+ amount (synth :extent doc))))

(defprim vcat (&rest docs)
  (:pretty () `(vcat (:docs ,(synth-all :pretty docs))))
  (:output (indent) (let ((fdocs (flatten docs)))
		     (unless (null fdocs) 
		       (progn (synth :output (car fdocs) indent)
			      (unless (null (cdr fdocs)) 
				(progn (format t "~%"))
				(synth :output (apply #'vcat (cdr fdocs)) indent))))))
  (:string () (with-output-to-string (*standard-output*)
			(synth :output this 0)))
  (:doc () this)  
  (:extent () (let ((fdocs (flatten docs)))
		     (synth :extent (car (last fdocs))))))

(defun hcat+ (&rest docs)
  (apply #'hcat (interleave docs (blank))))

(defprim hcat (&rest docs)
  (:pretty () `(hcat (:docs ,(synth-all :pretty docs))))
  (:output (indent) (let ((fdocs (flatten docs)))
		     (unless (null fdocs) 
		     	 (progn (synth :output (car fdocs) indent)
		     		(synth :output (apply #'hcat (cdr fdocs)) (+ indent (synth :extent (car fdocs))))))))
  (:string () (with-output-to-string (*standard-output*)
			(synth :output this 0)))
  (:doc () (apply #'hcat docs))
  (:extent () (let ((fdocs (flatten docs)))
	       (reduce #'+ (synth-all :extent fdocs)))))

(defun append* (&rest args)
  (let ((args* (mapcar (lambda (arg) 
                         (cond ((null arg) nil)
                               ((atom arg) (list arg))
                               (t arg)))
                       args)))
    (apply #'append args*)))

(defmacro vcat-all (fn lst)
  `(apply #'vcat (mapcar #',fn ,lst)))

(defun textify (sym)
  (text "~a" sym))

(defun wrap (doc start end &key newline (padding 0))
(if newline 
      (vcat start doc end)
      (hcat start (padding padding) doc (padding padding) end)))

(defmacro defwrapper (name start end)
  `(defun ,name (doc &key newline (padding 0))
     (wrap doc (text ,start) (text ,end) :newline newline :padding padding)))

(defwrapper parens "(" ")")
(defwrapper brackets "[" "]")
(defwrapper braces "{" "}")
(defwrapper angular "<" ">")
(defwrapper single-quotes "'" "'")
(defwrapper double-quotes "\"" "\"")
(defwrapper back-quotes "`" "`")

(defun padding (p)
  (text "~a" (make-string p :initial-element #\Space)))

(defun comma ()
  (text ","))
(defun dot ()
  (text "."))
(defun semi ()
  (text ";"))
(defun colon ()
  (text ":"))
(defun forward-slash ()
  (text "/"))
(defun equals () 
  (text "="))
(defun blank () 
  (text " "))

(defun punctuate (p newline &rest docs)
  (cond ((null docs) nil)
	((eq 1 (length docs)) (car docs))
	(t (if newline
	       (vcat (hcat (car docs) p) (apply #'punctuate p newline (cdr docs)))
	       (hcat (car docs) p (apply #'punctuate p newline (cdr docs)))))))

(defun prepend (p newline &rest docs)
  (cond ((null docs) (empty)) 
	((eq 1 (length docs)) (hcat p (car docs)))
        (t (if newline
               (vcat (hcat p (car docs)) (apply #'prepend p newline (cdr docs)))
	       (hcat p (car docs) (apply #'prepend newline (cdr docs)))))))

(defun postpend (p newline &rest docs)
  (cond ((null docs) (empty)) 
	((eq 1 (length docs)) (hcat (car docs) p))
        (t (if newline
	       (vcat (hcat (car docs) p) (apply #'postpend p newline (cdr docs)))
	       (hcat (car docs) p (apply #'postpend newline (cdr docs)))))))


